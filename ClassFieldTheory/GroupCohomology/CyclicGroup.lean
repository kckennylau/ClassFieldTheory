import ClassFieldTheory.GroupCohomology.LeftRegular

noncomputable section cyclicGroup
/-
In this section `G` is a cyclic group generated by an element `gen`.
We define `v₁ : leftRegular ℤ G` to be the element `of 1 - of gen`.
-/
variable {R G : Type} [Group G] [IsCyclic G] [CommRing R]

open Classical Finsupp IsCyclic CategoryTheory.ConcreteCategory
open Rep hiding of
open scoped CategoryTheory BigOperators

/--
`gen : G` is the generator of a cyclic group `G`
-/
abbrev IsCyclic.gen : G := exists_generator.choose

/--
Every element of a cyclic group `G` is a power of the generator `gen`.
-/
lemma IsCyclic.gen_spec (g : G) : ∃ n : ℤ, IsCyclic.gen ^ n = g :=
  IsCyclic.exists_generator.choose_spec g

namespace Rep.leftRegular

variable (R G)
/--
Given a cyclic group `G` generated by `gen`,
`diff₁` is the map `leftRegular ℤ G` to itself, taking `of g` to `of g - of (g * gen)`.
-/
def diff₁ : leftRegular R G ⟶ leftRegular R G :=
    (leftRegularHomEquiv (leftRegular R G)).symm (of 1 - of gen)

variable {R G}

@[simp]
lemma diff₁_of_one : diff₁ R G (of 1) = of 1 - of gen := by
  have := leftRegularHomEquiv_apply (leftRegular R G) (diff₁ R G)
  simp only [diff₁, LinearEquiv.apply_symm_apply] at this
  exact this.symm

lemma diff₁_of (g : G) : diff₁ R G (of g) = of g - of (g * gen) :=
by
  rw [of_eq_ρReg_of_one, Rep.apply_eq_hom, hom_comm_apply, ←apply_eq_hom, diff₁_of_one,
    map_sub, ←ρReg_apply_of]

@[simp] theorem ε_comp_diff₁ : diff₁ R G ≫ ε R G = 0 := by
  apply Hom.ext
  rw [Rep.comp_apply, diff₁_of, apply_eq_hom, map_sub, ←apply_eq_hom, ←apply_eq_hom, ε_of, ε_of,
    sub_self, Rep.zero_apply]


/-
For any `g : G`, the element `of g - of 1` of the left regular representation is in the image of
`diff₁`. This is a step on the way to proving that the image of `diff₁` is equal to the kernel of
`ε`.
-/
lemma of_sub_of_one_mem_range_diff₁ (g : G) :
    of g - of 1 ∈ LinearMap.range (diff₁ R G).hom.hom := by
  obtain ⟨n,rfl⟩ := IsCyclic.gen_spec g
  cases n with
  | ofNat n =>
    induction n with
    | zero =>
      use 0
      simp
    | succ n ih =>
      obtain ⟨w,hw⟩ := ih
      use ρReg gen w - of 1
      rw [Int.ofNat_eq_natCast, zpow_natCast] at hw
      rw [Int.ofNat_eq_natCast, zpow_natCast, map_sub, hom_comm_apply, hw, map_sub, ρReg_apply_of,
        ρReg_apply_of, pow_succ', ←apply_eq_hom, diff₁_of_one, mul_one, sub_sub_sub_cancel_right]
  | negSucc n =>
    simp only [apply_eq_hom, zpow_negSucc]
    induction n with
    | zero =>
      use of gen⁻¹
      rw [←apply_eq_hom, diff₁_of, inv_mul_cancel, zero_add, pow_one]
    | succ n ih =>
      obtain ⟨w,hw⟩ := ih
      rw [←apply_eq_hom] at hw
      use ρReg gen⁻¹ w + of gen⁻¹
      rw [map_add, ←apply_eq_hom, ←apply_eq_hom, diff₁_of, hom_comm_apply', ←ρReg, hw, map_sub,
        ρReg_apply_of, ←of_eq_ρReg_of_one, inv_mul_cancel, sub_add_sub_cancel]
      group

/--
The sequence `leftRegular R G ⟶ leftRegular R G ⟶ trivial R G R` is exact,
where the first map is `diff₁` and the second is `ε`.
-/
theorem exact_ε_diff₁ : LinearMap.ker (ε R G).hom.hom = LinearMap.range (diff₁ R G).hom.hom :=
by
  apply eq_of_le_of_le
  · intro v hv
    rw [LinearMap.mem_ker, ←apply_eq_hom, ε_eq_sum_coeff] at hv
    let pre (g : G) : leftRegular R G :=
      (of_sub_of_one_mem_range_diff₁ g).choose
    have pre_spec (g : G) : diff₁ R G (pre g) = of g - of 1 :=
      (of_sub_of_one_mem_range_diff₁ g).choose_spec
    let S := (coeff v).support
    use ∑ g ∈ S, coeff v g • pre g
    rw [map_sum]
    conv => {
      left
      right
      intro x
      rw [map_smul, ←apply_eq_hom, pre_spec, smul_sub]
    }
    rw [Finset.sum_sub_distrib, ←Finset.sum_smul, hv, zero_smul, sub_zero, ←eq_sum_smul_of]
  · rw [LinearMap.range_le_ker_iff]
    ext x
    change (diff₁ R G ≫ ε R G) (of x) = 0
    rw [ε_comp_diff₁, Rep.zero_apply]

-- theorem exact_ε_diff₁' (v : leftRegular R G) (hv : ε R G v = 0) :
--   ∃ w : leftRegular R G, v = diff₁ R G w :=
-- by
--   let pre (g : G) : leftRegular R G :=
--     (of_sub_of_one_mem_range_diff₁ g).choose
--   have pre_spec (g : G) : diff₁ R G (pre g) = of g - of 1 :=
--     (of_sub_of_one_mem_range_diff₁ g).choose_spec
--   let S := (coeff v).support
--   use ∑ g ∈ S, coeff v g • pre g
--   simp only [map_sum, LinearMapClass.map_smul]
--   symm
--   trans ∑ x ∈ S, coeff v x • (of x - of 1)
--   · congr
--     ext x
--     congr
--     exact pre_spec x
--   · simp only [smul_sub, Finset.sum_sub_distrib]
--     symm
--     trans v - 0
--     · simp
--     · congr
--       · apply eq_sum_smul_of
--       · symm
--         rw [←Finset.sum_smul, ←ε_eq_sum_coeff, hv, zero_smul]

lemma coeff_diff₁_gen_mul (v : leftRegular R G) (g : G) :
    coeff (diff₁ R G v) (gen * g) = coeff v (gen * g) - coeff v g :=
by
  rw [apply_eq_hom, diff₁, map_sub, sub_hom, ModuleCat.sub_apply, map_sub, sub_apply]
  congr 1
  · congr
    change (leftRegularHom (leftRegular R G) (of 1)) v = v
    suffices : (leftRegularHom (leftRegular R G) (of 1)) = CategoryTheory.CategoryStruct.id _
    · rw [this]
      rfl
    apply Hom.ext
    apply leftRegularHom_apply
  · convert coeff_ρReg_apply_self_mul gen v g
    rw [leftRegularHomEquiv_symm_apply]
    apply leftRegularHom_eq_ρReg
    rw [Subgroup.mem_center_iff]
    intro g
    obtain ⟨n,rfl⟩ := gen_spec g
    group

lemma diff₁_apply_eq_zero {v : leftRegular R G} (hv : diff₁ R G v = (0 : leftRegular R G)) (g : G) :
    coeff v g = coeff v 1 :=
by
  have (h : G) : coeff v (gen * h) = coeff v h
  · have := coeff_diff₁_gen_mul v h
    rw [hv] at this
    apply eq_of_sub_eq_zero this.symm
  obtain ⟨n,rfl⟩ := gen_spec g
  cases n
  case intro.ofNat n =>
    induction n with
    | zero => simp
    | succ n ih =>
      simp only [apply_eq_hom, Int.ofNat_eq_coe, zpow_natCast, Nat.cast_succ] at *
      norm_cast at *
      rw [pow_succ', this, ih]
  case intro.negSucc n =>
    induction n with
    | zero =>
      simp only [Nat.zero_eq, Int.reduceNegSucc, zpow_neg, zpow_one]
      have := this (gen⁻¹)
      rw [←this, mul_inv_cancel]
    | succ n ih =>
      have := this (gen ^ Int.negSucc n.succ)
      rw [←this]
      convert ih
      group
      congr

end Rep.leftRegular


noncomputable section finiteCyclic

open Rep hiding of
open Classical Finsupp BigOperators leftRegular
open scoped CategoryTheory

variable [Fintype G]

section not_cyclic
omit [IsCyclic G]

/--
`normElt` is the sum of the group elements, or equivalently
the element `G →₀ ℤ` all of whose values are `1`.
-/
def normElt : (leftRegular R G) := equivFunOnFinite.symm 1
notation "N[" G "," R "]" => normElt (G := G) (R := R)

lemma normElt_def : N[G,R] = equivFunOnFinite.symm 1 := rfl

@[simp]
lemma coe_coeff_normElt : (coeff normElt : G → R) = 1 := rfl

lemma support_normElt [Nontrivial R] : (coeff normElt : G →₀ R).support = Fintype.elems :=
by
  ext
  simp [Fintype.complete]

lemma normElt_eq_sum : normElt (G := G) (R := R) = ∑ g ∈ Fintype.elems, (of g) :=
by
  by_cases hR : Nontrivial R
  · rw [eq_sum_smul_of normElt]
    simp
    apply Finset.sum_congr
    rw [support_normElt]
    tauto
  · by_contra h
    have := nontrivial_of_ne _ _ h
    rw [nontrivial_iff_nontrivial] at this
    contradiction

@[simp] lemma ρReg_normElt (g : G) : ρReg g normElt (R := R) = normElt :=
by
  ext x
  rw [coeff_ρReg_apply]
  simp

lemma leftRegularHom_normElt {A : Rep R G} (a : A) :
    (leftRegularHom A a).hom normElt = ∑ g ∈ Fintype.elems, A.ρ g a :=
by
  rw [normElt_eq_sum, map_sum]
  apply Finset.sum_congr rfl
  intros
  apply leftRegularHom_of

@[simp] lemma leftRegularHom_normElt_of (g : G) :
    (leftRegularHom (leftRegular R G) (of g)).hom normElt = normElt :=
by
  rw [leftRegularHom_normElt, normElt_eq_sum]
  let my_equiv : G ≃ G := {
    toFun := (· * g)
    invFun := (· * g⁻¹)
    left_inv := by
      intro
      dsimp
      group
    right_inv := by
      intro
      dsimp
      group
  }
  apply Finset.sum_equiv my_equiv
  · simp [Fintype.complete]
  · intro x _
    rw [←ρReg, ρReg_apply_of]
    rfl

def diff₂ : leftRegular R G ⟶ leftRegular R G :=
  leftRegularHom _ normElt
notation "diff₂[" R "," G "]" => diff₂ (G := G) (R := R)

@[simp] lemma diff₂_of (x : G) : diff₂.hom (of x) = normElt (R := R) :=
by
  have : diff₂.hom (of (1 : G)) = normElt (R := R) := leftRegularHom_apply _
  rw [of_eq_ρReg_of_one, hom_comm_apply, this]
  apply ρReg_normElt

end not_cyclic


@[simp] lemma diff₂_comp_diff₁ : diff₁[R,G] ≫ diff₂ = 0 :=
by
  apply Hom.ext
  simp

@[simp] lemma diff₁_comp_diff₂ : diff₂[R,G] ≫ diff₁ = 0 :=
by
  apply Hom.ext -- `ext` would apply a weaker lemma here.
  simp only [Action.comp_hom, ModuleCat.hom_comp, LinearMap.coe_comp, Function.comp_apply, diff₂_of,
    Action.zero_hom, ModuleCat.hom_zero, LinearMap.zero_apply, diff₁, map_sub,
    leftRegularHomEquiv_symm_apply, sub_hom, ModuleCat.zero_apply', sub_eq_zero_of_eq,ModuleCat.sub_apply, sub_eq_zero]
  trans normElt
  · apply leftRegularHom_normElt_of
  · symm
    apply leftRegularHom_normElt_of


variable (R) (G)

def myResolution : ChainComplex (Rep R G) ℕ where
  X _       := leftRegular R G
  d i j     := if (ComplexShape.down ℕ).Rel i j then
                  (if Even i then diff₂ else diff₁) else 0
  d_comp_d' := by
    intro i j k hij hjk
    dsimp only [ComplexShape.down_Rel] at hij hjk ⊢
    rw [←hij, ←hjk, if_pos rfl, if_pos rfl]
    simp only [Nat.even_add_one]
    split_ifs with h
    · exact diff₂_comp_diff₁
    · exact diff₁_comp_diff₂

variable {R} {G}

lemma myResolution_X : (myResolution R G).X n = leftRegular R G := rfl

@[simp] lemma myResolution_d :
    (myResolution R G).d i j = if (ComplexShape.down ℕ).Rel i j then (if Even i then diff₂ else diff₁ (R := R) (G := G)) else 0 := rfl

-- @[simp] lemma myResolution_d' :
--     (myResolution R G).d (j + 1) j = if Even (j + 1) then diff₂ else diff₁ (R := R) (G := G) :=
-- by
--   simp


open IsCyclic

-- lemma diff₁_apply_eq_zero (hv : diff₁ v = (0 : leftRegular R G)) (g : G) : coeff v g = coeff v 1 :=
-- by
--   have (h : G) : coeff v (gen * h) = coeff v h
--   · have := coeff_diff₁_gen_mul v h
--     rw [hv] at this
--     apply eq_of_sub_eq_zero this.symm
--   obtain ⟨n,rfl⟩ := gen_spec g
--   cases n
--   case intro.ofNat n =>
--     induction n with
--     | zero => simp
--     | succ n ih =>
--       simp only [apply_eq_hom, Int.ofNat_eq_coe, zpow_natCast, Nat.cast_succ] at *
--       norm_cast at *
--       rw [pow_succ', this, ih]
--   case intro.negSucc n =>
--     induction n with
--     | zero =>
--       simp only [Nat.zero_eq, Int.reduceNegSucc, zpow_neg, zpow_one]
--       have := this (gen⁻¹)
--       rw [←this, mul_inv_cancel]
--     | succ n ih =>
--       have := this (gen ^ Int.negSucc n.succ)
--       rw [←this]
--       convert ih
--       group
--       congr



theorem exact_diff₁_diff₂ (v : leftRegular R G) (hv : diff₁ v = (0: leftRegular R G)) :
    ∃ w : leftRegular R G, diff₂ w = v :=
by
  use coeff v 1 • of 1
  apply leftRegular.ext
  intro
  trans coeff v 1
  · simp
  · exact (diff₁_apply_eq_zero hv _).symm

theorem exact_diff₂_diff₁ : LinearMap.ker diff₂[G,R].hom.hom ≤ LinearMap.range diff₁[G,R].hom.hom := by
  intro v hv
  rw [LinearMap.mem_ker, eq_sum_smul_of v, map_sum] at hv
  simp only [LinearMapClass.map_smul, diff₂_of] at hv
  rw [←Finset.sum_smul] at hv
  have : coeff ((∑ i ∈ (coeff v).support, (coeff v) i) • N[G,R]) (1 : G) = 0
  · rw [hv, map_zero, zero_apply]
  simp only [map_smul, coe_smul, coe_coeff_normElt, Pi.smul_apply, Pi.one_apply, smul_eq_mul,
    mul_one] at this
  rw [←exact_ε_diff₁, LinearMap.mem_ker, ε_eq_sum_coeff, this]

/-
# TODO

Change this to use the Mathlib definition of exactness.
-/

--#check CategoryTheory.Exact
#check HomologicalComplex.ExactAt (myResolution R G) 1
#check CategoryTheory.ShortComplex.Exact

open CategoryTheory

variable (R G)

def myShortComplex₁ : ShortComplex (Rep R G) where
  X₁ := leftRegular R G
  X₂ := leftRegular R G
  X₃ := leftRegular R G
  zero := diff₂_comp_diff₁

def myShortComplex₂ : ShortComplex (Rep R G) where
  X₁ := leftRegular R G
  X₂ := leftRegular R G
  X₃ := leftRegular R G
  zero := diff₁_comp_diff₂

-- #synth HasForget₂ (Rep R G) Ab
#synth Abelian (Rep R G)
-- #synth ConcreteCategory (Rep R G)
-- #synth ConcreteCategory Ab


#synth HasForget₂ (Rep R G) (ModuleCat R)

#synth HasForget₂ (ModuleCat R) Ab

#check forget₂ (Rep R G) (ModuleCat R)

#check (myShortComplex₁ R G).map (forget₂ (Rep R G) (ModuleCat R))

instance : HasForget₂ (Rep R G) Ab where
  forget₂ := forget₂ (Rep R G) (ModuleCat R) ⋙ forget₂ (ModuleCat R) Ab

instance : (forget₂ (Rep R G) Ab).Additive :=
  Functor.instAdditiveComp (forget₂ (Rep R G) (ModuleCat R)) (forget₂ (ModuleCat R) Ab)

instance : (forget₂ (Rep R G) Ab).PreservesHomology :=
  (forget₂ (Rep R G) (ModuleCat R) ⋙ forget₂ (ModuleCat R) Ab).preservesHomologyOfExact

lemma Exact₁ : (myShortComplex₁ R G).Exact :=
by
  rw [ShortComplex.exact_iff_exact_map_forget₂]
  rw [ShortComplex.ab_exact_iff_ker_le_range]
  exact exact_diff₂_diff₁

lemma Exact₂ : (myShortComplex₂ R G).Exact := by
  rw [ShortComplex.exact_iff_exact_map_forget₂]
  rw [ShortComplex.ab_exact_iff_ker_le_range]
  exact exact_diff₁_diff₂

example : HomologicalComplex.ExactAt (myResolution R G) 1 :=
by
  rw [HomologicalComplex.exactAt_iff]
  rw [ShortComplex.exact_iff_exact_map_forget₂]
  rw [ShortComplex.ab_exact_iff_ker_le_range]
  dsimp
  split_ifs with h₁ h₂ h₃
  · exact exact_diff₁_diff₂
  · exfalso
    simp at h₃
  · exfalso
    simp at h₂
  · simp at h₁
  · simp at h₁
  · simp at h₁



example : (myResolution R G).homology 0 ≅ trivial R G R where
  hom := {
    hom := by
      rw [HomologicalComplex.homology]

      rw [ShortComplex.homology]

      --convert ε (R :=R) (G := G)
      sorry
    comm := sorry
  }
  inv := sorry
  hom_inv_id := sorry
  inv_hom_id := sorry


variable (A : Rep R G)



def toSingle₀ : myResolution R G ⟶ (ChainComplex.single₀ _).obj (trivial R G R) :=
  ((myResolution R G).toSingle₀Equiv (trivial R G R)).symm ⟨ε, ε_comp_diff₁⟩


#check groupCohomology A
#check groupCohomologyIsoExt
#check CategoryTheory.ProjectiveResolution (trivial R G R)

example : CategoryTheory.ProjectiveResolution (trivial R G R) where
  complex := myResolution R G
  projective _ := by
    rw [myResolution_X]
    infer_instance
  hasHomology _ := inferInstance
  π := toSingle₀ R G
  quasiIso := by
    let inv : trivial R G R ⟶ (myResolution R G).homology 0 := by
      exact {
        hom := by
          apply ConcreteCategory.ofHom
          exact {
            toFun (r : R) := by

              sorry
            map_add' := sorry
            map_smul' := sorry
          }
        comm := sorry
      }

    exact {
      quasiIsoAt := by
        intro i
        cases i with
        | zero =>
          constructor
          constructor

          --rw [ShortComplex.quasiIso_iff]
          sorry
        | succ n =>
          rw [quasiIsoAt_iff_exactAt]
          · exact ChainComplex.exactAt_succ_single_obj (Rep.trivial R G R) n
          · rw [HomologicalComplex.exactAt_iff, ShortComplex.exact_iff_exact_map_forget₂, ShortComplex.ab_exact_iff_ker_le_range]
            simp only [ShortComplex.map_X₂, HomologicalComplex.shortComplexFunctor_obj_X₂,
                ShortComplex.map_X₃, HomologicalComplex.shortComplexFunctor_obj_X₃,
                ShortComplex.map_g, HomologicalComplex.shortComplexFunctor_obj_g, myResolution_d,
                ChainComplex.next_nat_succ, ComplexShape.down_Rel, ↓reduceIte, ShortComplex.map_X₁,
                HomologicalComplex.shortComplexFunctor_obj_X₁, ShortComplex.map_f,
                HomologicalComplex.shortComplexFunctor_obj_f, ChainComplex.prev]
            by_cases hn : Even n
            · rw [if_neg, if_pos]
              exact exact_diff₁_diff₂
              · rwa [Nat.even_add_one, Nat.even_add_one, not_not]
              · rwa [Nat.even_add_one, not_not]
            · rw [if_pos, if_neg]
              exact exact_diff₂_diff₁
              · rwa [Nat.even_add_one, Nat.even_add_one, not_not]
              · rwa [Nat.even_add_one]
    }
