import Lean
import Mathlib.Tactic.ToAdditive.Frontend
import Lean.Meta.Tactic.TryThis

open Lean Elab Meta Tactic Command

def Lean.Syntax.replaceNames (f : Name → Name) : Syntax → Syntax
  | .node info kind args =>
    .node info kind (args.map <| replaceNames f)
  | .ident _ _ val _ =>
    mkIdent (f val)
  | stx => stx

def Lean.Syntax.replaceNamesM (f : Name → MetaM Name) : Syntax → MetaM Syntax
  | .node info kind args =>
    return .node info kind (← args.mapM <| replaceNamesM f)
  | .ident _ _ val _ =>
    return mkIdent (← f val)
  | stx => return stx

def Lean.TSyntax.replaceNames {ks} (f : Name → Name) : TSyntax ks → TSyntax ks :=
  (⟨·.raw.replaceNames f⟩)

def Lean.TSyntax.replaceNamesM {ks} (f : Name → MetaM Name) : TSyntax ks → MetaM (TSyntax ks) :=
  (return ⟨← ·.raw.replaceNamesM f⟩)

section Renaming

/-!

The code in this section is copied from
https://github.com/leanprover-community/mathlib4/pull/21719/,
specifically `Mathlib/Tactic/ToAdditive/Frontend.lean`.

-/

open ToAdditive in
/--
Turn each element to lower-case, apply the `nameDict` and
capitalize the output like the input.
-/
def applyNameDict (nameDict : String → List String) : List String → List String
  | x :: s => (capitalizeFirstLike x (nameDict x.toLower)) ++ applyNameDict nameDict s
  | [] => []

/--
Autogenerate additive name.
This runs in several steps:
1) Split according to capitalisation rule and at `_`.
2) Apply word-by-word translation rules.
3) Fix up abbreviations that are not word-by-word translations, like "addComm" or "Nonneg".
-/
def guessName (nameDict : String → List String) (fixAbbreviation : List String → List String) :
    String → String :=
  String.mapTokens '\'' <|
  fun s =>
    String.join <|
    fixAbbreviation <|
    applyNameDict nameDict <|
    s.splitCase

end Renaming

def dualizationNameDict : String → List String
  | "homology"   => ["cohomology"]
  | "cohomology" => ["homology"]
  | x            => [x]

def dualizationFixAbbreviation : List String → List String
  | "tate" :: "Homology" :: s => "tateCohomology" :: s
  | "Tate" :: "Homology" :: s => "tateCohomology" :: s
  | x :: s                    => x :: dualizationFixAbbreviation s
  | []                        => []

def dualizationRename (name : Name) : Name :=
  let components := name.components
  let renamings := components.map fun cmp ↦
    guessName dualizationNameDict dualizationFixAbbreviation cmp.toString
  renamings.foldl (init := .anonymous) .str

/--
The command below was automatically generated by the `#dualize` command,
which swaps out all names involving "cohomology" with "homology", and vice versa.
-/
syntax ppDedentIfGrouped("dualized_to" command) : command

macro_rules
| `(command| dualized_to $cmd') => `(command| $cmd')

/--
This is a command to reduce the repetitive work of proving things twice,
once for homology and again for cohomology.

Writing #dualize beneath a theorem/lemma/structure/class offers a pop-up that
suggests a dual version where all the names involving
"cohomology" have been swapped with "homology" and vice-versa.
-/
elab cmd:command tk:"#dualize" : command => do
  let cmd' := cmd.replaceNames dualizationRename
  elabCommand cmd
  let result : TSyntax `command ← `(command| dualized_to $cmd')
  let σ ← get
  let suggestionStyle : SuggestionStyle ← do
    try do
      elabCommand cmd'
      pure .success
    catch _ => pure .warning
  set σ
  runTermElabM fun _ ↦ do
    TryThis.addSuggestion tk
      -- (origSpan? := ← getRef)
      (header := "Dualized result: ")
      (codeActionPrefix? := "Dualize: ")
      { suggestion := result,
        style? := some suggestionStyle }
